import{useState as n,useRef as t,useEffect as r,useCallback as e}from"react";import u from"next-tick";const c=c=>{const{done:i,drain:m,inflight:o,isPaused:s}=c;let{concurrency:g}=c;g<1&&(g=Infinity);const[h,l]=n({numPending:0,numInFlight:0,numDone:0}),a=t(!0),d=t([]),p=t([]);r(()=>{if(!s){if(h.numDone>0&&m&&0===d.current.length&&0===p.current.length&&!a.current)return a.current=!0,u(m);for(;d.current.length<g&&p.current.length>0;){a.current=!1;const n=p.current.shift();d.current.push(n),l(n=>({...n,numPending:n.numPending-1,numInFlight:n.numInFlight+1})),o&&o({...n,stats:h});const t=n.task();t.then(()=>{d.current.pop(),l(n=>({...n,numInFlight:n.numInFlight-1,numDone:n.numDone+1})),i&&i({...n,result:t,stats:h})}).catch(()=>{d.current.pop(),l(n=>({...n,numInFlight:n.numInFlight-1,numDone:n.numDone+1})),i&&i({...n,result:t,stats:h})})}}},[g,i,m,o,h]);const f=e(n=>{p.current.push(n),l(n=>({...n,numPending:n.numPending+1}))},[]);return{add:f,stats:h}};export{c as useRnAsyncQueue};
//# sourceMappingURL=use-rn-async-queue.esm.js.map
